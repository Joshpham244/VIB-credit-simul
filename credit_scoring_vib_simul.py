# -*- coding: utf-8 -*-
"""credit scoring vib simul.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YD_eObHFuoHmKFlvHDVxfTWNppmBjbDI
"""



import pandas as pd
import scipy as sp
import numpy as np
import seaborn as sns
from sklearn.metrics import classification_report, confusion_matrix
from statsmodels.stats.outliers_influence import variance_inflation_factor
import matplotlib.pyplot as plt
from sklearn.metrics import classification_report
import sklearn.metrics as metrics
import matplotlib.pyplot as plt
import streamlit as st
import plotly.tools as tls

#machine learning
import lightgbm as lgb
from sklearn.model_selection import train_test_split
#run ml librabries
from sklearn.preprocessing import MinMaxScaler

from xgboost import XGBClassifier
import xgboost as xgb
from sklearn.metrics import plot_roc_curve

def housing_time(df):
  condition = [
             (df['age']<20),#Less than 1 year
             (df['age']>=20)&(df['age']<24), #1-3 years
             (df['age']>=24)&(df['age']<35),#3-6 years
             (df['age']>=35)&(df['age']<50),#6-10 years
             (df['age']>=50)]
  choice =['less_1_years', '1-3_years','3-6_years','6-10_years','over_10_years']
  df['housing_time'] = np.select(condition, choice)
  return df['housing_time']

def income(df):
  conditions = [ 
              (df['job']=='skilled employee') ,
              (df['job']=='unskilled resident') ,
              (df['job']=='mangement self-employed') ,(df['job']=='unemployed non-resident')]
  values = ['>8mill','5-8mil','3-5mil','2-3mil']
  df['Income'] = np.select(conditions, values)
  return df['Income']

def education(df):
  np.random.seed(445)
  df['education'] = np.random.choice(  
     a=['over_university_aboard', 'over_university_country', 'university','highschool'],  
    size=1000,  
     p=[0.1, 0.2, 0.5, 0.2] ) 
  return df['education']

def preprocess(df):
  df['amount'] = df['amount']*13346
  df = df.rename(columns={'default':'TARGET'})
  df['TARGET'].replace({2:1,1:0}, inplace=True)
  df['employment_length'].replace({'1 - 4 yrs':'1-3_years', '> 7 yrs':'>5_years','4 - 7 yrs':'3-5_years',
                                 '0 - 1 yrs':'0-1_years'},inplace=True)
  df = df.astype({"existing_credits":'category'})

  df['existing_credits'].replace({1:'1_vib_card',2:'2_vib_card', 3:'another_bank', 4:'another_bank'}, inplace=True)

  df['monthly_payment'] = (df['amount']*(df['installment_rate']/1200)*(1+df['installment_rate']/1200)**(df['months_loan_duration']))/((1+df['installment_rate']/1200)**(df['months_loan_duration'])-1)
  df['monthly_payment'] =round(df['monthly_payment'],0)

  df['housing_time'] = round(df['age']/df['residence_history'],0)
  if (df['residence_history'] == 1).any():df['housing_time']=df['age']

  df['housing_time'] = housing_time(df)
  df['Income'] = income(df)
  df['education']  = education(df)
  credit_vib = df[['age','education', 'dependents','personal_status','housing','housing_time','employment_length','job','existing_credits','Income','monthly_payment','TARGET']]
  return credit_vib

def age(df):
  conditions = [ 
              (df['age']<21) & (df['age']>=18),
              (df['age']<30) & (df['age']>=21),
              (df['age']>=30) & (df['age']<50),
              (df['age']>=60) & (df['age']<60)]
  values = [5, 6, 9, 8]
  Scoring_board['AGE_POINT'] = np.select(conditions, values)
  return Scoring_board['AGE_POINT']


def education_point(df):
  conditions = [ 
              (df['education']=='university'),
              (df['education']=='over_university_country'),
              (df['education']=='highschool'),
              (df['education']=='over_university_aboard')]
  values = [7, 8, 5, 9]
  Scoring_board['EDU_POINT'] = np.select(conditions, values)
  return Scoring_board['EDU_POINT']

def CHILD(df):
  conditions = [ 
              (df['dependents']==0),
              (df['dependents']==1),
              (df['dependents']==2),
              (df['dependents']==3),
              (df['dependents']>=4)]
  values = [5, 8, 7, 6, 4]
  Scoring_board['CHILD_POINT'] = np.select(conditions, values)
  return Scoring_board['CHILD_POINT']

def FAM_STATUS(df):
  conditions = [ 
              (df['personal_status']=='single male'),
              (df['personal_status']=='female'),
              (df['personal_status']=='married male'),
              (df['personal_status']=='divorced male')]
  values = [7, 7, 9, 6]
  Scoring_board['FAM_STATUS_POINT'] = np.select(conditions, values)
  return Scoring_board['FAM_STATUS_POINT']

def housing(df):
  conditions = [ 
              (df['housing']=='own'),
              (df['housing']=='rent'),
              (df['housing']=='for free')]
  values = [9, 4, 6]
  Scoring_board['HOUSING_POINT'] = np.select(conditions, values)
  return Scoring_board['HOUSING_POINT']

def HOUSING_TIME_POINT(df):
  conditions = [ 
              (df['housing_time']=='less_1_years'),
              (df['housing_time']=='1-3_years'),
              (df['housing_time']=='3-6_years'),
              (df['housing_time']=='6-10_years'),
              (df['housing_time']=='over_10_years')]
  values = [6, 7, 8, 9, 10]
  Scoring_board['HOUSING_TIME_POINT'] = np.select(conditions, values)
  return Scoring_board['HOUSING_TIME_POINT']

def EMP_length_point(df):
  conditions = [ 
              (df['employment_length']=='1-3_years'),
              (df['employment_length']=='>5_years'),
              (df['employment_length']=='3-5_years'),
              (df['employment_length']=='0-1_years'),
              (df['employment_length']=='unemployed')]
  values = [7, 9, 8, 6, 0]
  Scoring_board['EMP_length_point'] = np.select(conditions, values)
  return Scoring_board['EMP_length_point']

def job_point(df):
  conditions = [ 
              (df['job']=='mangement self-employed'),
              (df['job']=='skilled employeet'),
              (df['job']=='unskilled resident'),
              (df['job']=='unemployed non-resident')]
  values = [9, 8, 7, 0]
  Scoring_board['job_point'] = np.select(conditions, values)
  return Scoring_board['job_point']
  
def existing_credits_point(df):
  conditions = [ 
              (df['existing_credits']=='1_vib_card'),
              (df['existing_credits']=='2_vib_card'),
              (df['existing_credits']=='another_bank')]
  values = [7, 8, 6]
  Scoring_board['existing_credits_point'] = np.select(conditions, values)
  return Scoring_board['existing_credits_point']

def Income(df):
  conditions = [ 
              (df['Income']=='>8mill'),
              (df['Income']=='5-8mil'),
              (df['Income']=='3-5mil'),
              (df['Income']=='2-3mil')]
  values = [9, 8, 7, 5]
  Scoring_board['Income_point'] = np.select(conditions, values)
  return Scoring_board['Income_point']

def monthly_payment_POINT(df):
  conditions = [ 
              (df['monthly_payment']<500000),
              (df['monthly_payment']>=500000)&(df['monthly_payment']<1000000),
              (df['monthly_payment']>=1000000)&(df['monthly_payment']<3000000),
              (df['monthly_payment']>=3000000)&(df['monthly_payment']<5000000),
              (df['monthly_payment']>=5000000)]
  values = [5, 6, 8, 9, 10]
  Scoring_board['monthly_payment_POINT'] = np.select(conditions, values)
  return Scoring_board['monthly_payment_POINT']

Scoring_board = pd.DataFrame()
def weighted_scoring(df):
  Scoring_board['AGE_POINT'] = age(df)
  Scoring_board['EDU_POINT'] = education_point(df)
  Scoring_board['CHILD_POINT'] = CHILD(df)
  Scoring_board['FAM_STATUS_POINT'] = FAM_STATUS(df)
  Scoring_board['job_point'] = job_point(df)
  Scoring_board['HOUSING_POINT'] = housing(df)
  Scoring_board['HOUSING_TIME_POINT'] = HOUSING_TIME_POINT(df)
  Scoring_board['EMP_length_point'] = EMP_length_point(df)
  Scoring_board['existing_credits_point'] = existing_credits_point(df)
  Scoring_board['Income_point'] = Income(df)
  Scoring_board['monthly_payment_POINT'] = monthly_payment_POINT(df)
  Scoring_board['credit_point'] = 0.04*Scoring_board['AGE_POINT'] + 0.05*Scoring_board['EDU_POINT'] + 0.05*Scoring_board['CHILD_POINT']+0.05*Scoring_board['FAM_STATUS_POINT']+0.15*Scoring_board['HOUSING_POINT']+0.03*Scoring_board['HOUSING_TIME_POINT']+0.04*Scoring_board['EMP_length_point']+0.05*Scoring_board['job_point']+0.05*Scoring_board['existing_credits_point']+0.35*Scoring_board['Income_point']+0.05*Scoring_board['monthly_payment_POINT']
  return Scoring_board


def result(Scoring_board, df) :
  conditions = [ 
              (Scoring_board['credit_point']>7),
              (Scoring_board['credit_point']<=7)]
  
  values = [0, 1]
  df['ESTIM_TARGET'] = np.select(conditions, values)
  df = df.groupby('TARGET', group_keys=False).apply(lambda x: x.sample(frac=0.2))
  #plot
  domain_fpr, domain_tpr, domain_threshold = metrics.roc_curve(df.TARGET, df.ESTIM_TARGET)
  domain_roc_auc = metrics.auc(domain_fpr, domain_tpr)
  fig,ax = plt.subplots()

  ax.title = plt.title('Receiver Operating Characteristic')
  ax.plot(domain_fpr, domain_tpr, '^', label='domain (AUC = %0.2F)' % domain_roc_auc)
  ax.legend(loc = 'lower right')
  ax.plot([0, 1], [0, 1],'r--')
  ax.set(xlim=(0,1),ylim=(0, 1))
  ax.set_ylabel('True Positive Rate')
  ax.set_xlabel('False Positive Rate')
  plotly_fig = tls.mpl_to_plotly(fig)

  return plotly_fig  
def plot_feature_importances(df, threshold = 0.9):
    """
    Plots 15 most important features and the cumulative importance of features.
    Prints the number of features needed to reach threshold cumulative importance.
    
    Parameters
    --------
    df : dataframe
        Dataframe of feature importances. Columns must be feature and importance
    threshold : float, default = 0.9
        Threshold for prining information about cumulative importances
        
    Return
    --------
    df : dataframe
        Dataframe ordered by feature importances with a normalized column (sums to 1)
        and a cumulative importance column
    
    """
    
    plt.rcParams['font.size'] = 18
    
    # Sort features according to importance
    df = df.sort_values('importance', ascending = False).reset_index()
    
    # Normalize the feature importances to add up to one
    df['importance_normalized'] = df['importance'] / df['importance'].sum()
    df['cumulative_importance'] = np.cumsum(df['importance_normalized'])

    # Make a horizontal bar chart of feature importances
    plt.figure(figsize = (10, 6))
    ax = plt.subplot()
    
    # Need to reverse the index to plot most important on top
    ax.barh(list(reversed(list(df.index[:15]))), 
            df['importance_normalized'].head(15), 
            align = 'center', edgecolor = 'k')
    
    # Set the yticks and labels
    ax.set_yticks(list(reversed(list(df.index[:15]))))
    ax.set_yticklabels(df['feature'].head(15))
    
    # Plot labeling
    plt.xlabel('Normalized Importance'); plt.title('Feature Importances')
    plt.show()
    
    # Cumulative importance plot
    plt.figure(figsize = (8, 6))
    plt.plot(list(range(len(df))), df['cumulative_importance'], 'r-')
    plt.xlabel('Number of Features'); plt.ylabel('Cumulative Importance'); 
    plt.title('Cumulative Feature Importance');
    plt.show();
    
    importance_index = np.min(np.where(df['cumulative_importance'] > threshold))
    print('%d features required for %0.2f of cumulative importance' % (importance_index + 1, threshold))
    
    return df
def preprocess_ml(credit_vib):
  credit_vib.drop(columns=['job','personal_status'], inplace = True)
  credit_vib = pd.get_dummies(credit_vib, drop_first= False)

  label = credit_vib['TARGET']
  df_train = credit_vib.copy()
  df_train = df_train.drop(columns=['TARGET'])

  Y = label.copy()
  X = df_train.copy()
  feat_names = list(X.columns)

  X_ids = X.index.values
  Y_ids = Y.index.values

  feature_importances = np.zeros(X.shape[1])
  model = lgb.LGBMClassifier(objective='binary', boosting_type = 'goss', n_estimators = 1000, class_weight = 'balanced')

  for i in range(2):
    train_features, valid_features, train_y, valid_y = train_test_split(X, Y, test_size = 0.25, random_state = i)
    model.fit(train_features, train_y, early_stopping_rounds=100, eval_set = [(valid_features, valid_y)], 
              eval_metric = 'auc', verbose = 200)
    feature_importances += model.feature_importances_
  feature_importances = feature_importances / 2

  feature_importances = pd.DataFrame({'feature': feat_names, 'importance': feature_importances}).sort_values('importance', ascending = False)
  zero_features = list(feature_importances[feature_importances['importance'] == 0.0]['feature'])
  norm_feature_importances = plot_feature_importances(feature_importances)
  df_train = df_train.drop(columns= zero_features)
  threshold = 0.95

  # Extract the features to keep
  features_to_keep = list(norm_feature_importances[norm_feature_importances['cumulative_importance'] < threshold]['feature'])

  # Create new datasets with smaller features
  df_new = df_train[features_to_keep]
  df_new['TARGET'] = Y
  return df_new
def ml_scoring(df_new):
  Xnew_train =df_new.copy()
  Y = Xnew_train['TARGET']
  Xnew_train = df_new.drop(columns=['TARGET','age'])
  X_train, X_test, Y_train, Y_test = train_test_split(Xnew_train, Y, test_size=.2,
                                                    random_state=0)

  X_train_ids = X_train.index.values
  X_test_ids = X_test.index.values

  feat_names = list(Xnew_train.columns)
  scaler = MinMaxScaler(feature_range= (0,1))
  scaler.fit(Xnew_train)

  X_train = scaler.transform(X_train)
  X_test = scaler.transform(X_test)

  clf2 = XGBClassifier(objective='multi:softprob', sampling_method ='gradient_based',booster='gbtree', seed=42, max_depth=1, learning_rate= 0.49221976744492657, gamma= 0.8807972671374964, reg_lambda=0.17934179652902277, num_class=2)
  clf2.fit(X_train, Y_train, verbose=True, early_stopping_rounds=10, eval_metric='mlogloss', eval_set=[[X_test, Y_test]])
  ax = plot_roc_curve(clf2, X_test, Y_test)
  return ax

#machine_learning scoring
def plot_feature_importances(df, threshold = 0.9):
    """
    Plots 15 most important features and the cumulative importance of features.
    Prints the number of features needed to reach threshold cumulative importance.
    
    Parameters
    --------
    df : dataframe
        Dataframe of feature importances. Columns must be feature and importance
    threshold : float, default = 0.9
        Threshold for prining information about cumulative importances
        
    Return
    --------
    df : dataframe
        Dataframe ordered by feature importances with a normalized column (sums to 1)
        and a cumulative importance column
    
    """
    
    plt.rcParams['font.size'] = 18
    
    # Sort features according to importance
    df = df.sort_values('importance', ascending = False).reset_index()
    
    # Normalize the feature importances to add up to one
    df['importance_normalized'] = df['importance'] / df['importance'].sum()
    df['cumulative_importance'] = np.cumsum(df['importance_normalized'])

    # Make a horizontal bar chart of feature importances
    plt.figure(figsize = (10, 6))
    ax = plt.subplot()
    
    # Need to reverse the index to plot most important on top
    ax.barh(list(reversed(list(df.index[:15]))), 
            df['importance_normalized'].head(15), 
            align = 'center', edgecolor = 'k')
    
    # Set the yticks and labels
    ax.set_yticks(list(reversed(list(df.index[:15]))))
    ax.set_yticklabels(df['feature'].head(15))
    
    # Plot labeling
    plt.xlabel('Normalized Importance'); plt.title('Feature Importances')
    plt.show()
    
    # Cumulative importance plot
    plt.figure(figsize = (8, 6))
    plt.plot(list(range(len(df))), df['cumulative_importance'], 'r-')
    plt.xlabel('Number of Features'); plt.ylabel('Cumulative Importance'); 
    plt.title('Cumulative Feature Importance');
    plt.show();
    
    importance_index = np.min(np.where(df['cumulative_importance'] > threshold))
    print('%d features required for %0.2f of cumulative importance' % (importance_index + 1, threshold))
    
    return df
def preprocess_ml(credit_vib):
  credit_vib.drop(columns=['job','personal_status'], inplace = True)
  credit_vib = pd.get_dummies(credit_vib, drop_first= False)

  label = credit_vib['TARGET']
  df_train = credit_vib.copy()
  df_train = df_train.drop(columns=['TARGET'])

  Y = label.copy()
  X = df_train.copy()
  feat_names = list(X.columns)

  X_ids = X.index.values
  Y_ids = Y.index.values

  feature_importances = np.zeros(X.shape[1])
  model = lgb.LGBMClassifier(objective='binary', boosting_type = 'goss', n_estimators = 1000, class_weight = 'balanced')

  for i in range(2):
    train_features, valid_features, train_y, valid_y = train_test_split(X, Y, test_size = 0.25, random_state = i)
    model.fit(train_features, train_y, early_stopping_rounds=100, eval_set = [(valid_features, valid_y)], 
              eval_metric = 'auc', verbose = 200)
    feature_importances += model.feature_importances_
  feature_importances = feature_importances / 2

  feature_importances = pd.DataFrame({'feature': feat_names, 'importance': feature_importances}).sort_values('importance', ascending = False)
  zero_features = list(feature_importances[feature_importances['importance'] == 0.0]['feature'])
  norm_feature_importances = plot_feature_importances(feature_importances)
  df_train = df_train.drop(columns= zero_features)
  threshold = 0.95

  # Extract the features to keep
  features_to_keep = list(norm_feature_importances[norm_feature_importances['cumulative_importance'] < threshold]['feature'])

  # Create new datasets with smaller features
  df_new = df_train[features_to_keep]
  df_new['TARGET'] = Y
  return df_new



def display(st,result):
    st.plotly_chart(result)
    st.markdown('<p style="font: 16px bold Georgia, serif; text-transform: uppercase; color: blue;text-align: center;">credit</p>',unsafe_allow_html=True)
    


if __name__ == "__main__":
    df= pd.read_csv('./credit.csv')
    preprocess = preprocess(df=df)
    #domain scoring
    weighted_df = weighted_scoring(df=preprocess)
    result = result(Scoring_board=weighted_df, df=preprocess)
    #machine learning scoring
    df_new = preprocess_ml(credit_vib=prepeocess)
    ml_result = ml_scoring(df_new=df_new)
    display(st, result=result)
